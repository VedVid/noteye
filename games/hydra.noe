-- which version of NotEye is this noe-file compatible with
gamenoteyever = 0x900

-- set the official Hydra Slayer colors
setpalette(palettes.hydra, 7)

conssize = V(80, 25)
map = rectXY(0, 0, 50, 22)
msgbox = {x0=0, x1=80, y0=22,y1=24}
minipos = V(1,1)
minimapsize = V(3,5)

addinfo(violenceinfo, 75, "show blood")
addinfo(violenceinfo, 25, "show corpses")

--function settilectr()
--  tilectr = {x=scroffset.x+25*fontsize.x, y=scroffset.y+11*fontsize.y}
--  end

inhex = false
spFloorH = spFloor

function alnumav(cc)
  if cc>=av("1") and cc <= av("9") then 
    return cc - av("0")
  elseif cc >= av("A") and cc <= av("Z") then 
    return cc - av("A") + 10
  elseif cc == av("0") then
    return 10 -- only possible in the hex mode
  else
    return 0
    end
  end

function alnum(c)
  return alnumav(av(c))
  end

dofile(commondir.."hydra-png.noe")
dofile(commondir.."hydra-ogg.noe")
dofile(commondir.."walls-png.noe")

Unseen = tilespatial(tilefill(0x181810), spFlat + spIFloor + spFloor + spCeil)
OutOfMap = tilespatial(tilefill(0x202018), spFlat + spIFloor + spFloor + spCeil)

function ytilefloor(M)
  if not M.floor then
    return Unseen
  elseif M.floor == " " then
    return nil
  elseif M.floor == av("#") then
    return Wall
  else
    return Lightfloor
    end
  end

function xtilefloor(C)

  if gp2(C) == nil then return nil end

  local ch = gch(C)
  local co = gco(C)
  if ch == " " then 
    return Unseen
  elseif ch == (".") and co == vgaget(12) then
    return Unseen
  elseif ch == (".") and co == vgaget(8) then
    return Darkfloor
  elseif ch == (":") and co == vgaget(4) then
    return Darkfloor
  elseif ch == ("%") and co == vgaget(8) then
    return Darkfloor
  elseif ch == ("<") and co == vgaget(8) then
    return Darkfloor
  elseif ch == (">") and co == vgaget(8) then
    return Darkfloor
  elseif ch == ("#") then
    return Wall
  else
    return Lightfloor
    end
  end

-- terrain features
Stairs = nil

if not Stairs then
  Stair = at(1,0)
  Stair1 = freeformparam(1,0.16,0,0.2, 0,0.2,0,0, 0,0,1,0, 0,0,0,1)
  Stair2 = freeformparam(1,0.32,0,0.4, 0,0.2,0,0, 0,0,1,0, 0,0,0,1)
  Stair3 = freeformparam(1,0.48,0,0.6, 0,0.2,0,0, 0,0,1,0, 0,0,0,1)
  Stair4 = freeformparam(1,0.64,0,0.8, 0,0.2,0,0, 0,0,1,0, 0,0,0,1)
  Stair5 = freeformparam(1,0,0,0,      0,0.2,0,0, 0,0.8,0,1, 0,0,0,1)
  Stair6 = freeformparam(1,0,1,0,      0,0.2,0,0, 0,0.8,0,1, 0,0,0,1)
  
  GotoRoof    = freeformparam(1,0,0,1,    0,1,0,0,   0,0,1,0,  0,0,0,-1)
  GotoRoofTop = freeformparam(1,0,0,1,    0,1,0,0,   0,0,1,0,  0,0,0,-1)
  HexWallEW   = freeformparam(1,1/6,0,-0.5, 0,2/3,0,0,   0,0,1,0,  0,0,0,1)
  HexWallSE   = freeformparam(1,0.5,0,-1/6, 0,1,0,1/3, 0,0,1,0, 0,0,0,1)
  HexWallSW   = freeformparam(1,-0.5,0,1/6, 0,1,0,-1/3, 0,0,1,0, 0,0,0,1)
  MoveDown    = freeformparam(1,0,0,-1,   0,1,0,0,   0,0,1,0,  0,0,0,1)
  
  freeformparamflags(GotoRoof, 2, false)
  freeformparamflags(GotoRoofTop, 1, false)
  freeformparamflags(Stair1, 0, false)
  freeformparamflags(Stair2, 0, false)
  freeformparamflags(Stair3, 0, false)
  freeformparamflags(Stair4, 0, false)
  freeformparamflags(Stair5, 0, false)
  freeformparamflags(Stair6, 0, false)
  
  -- freeformparamflags(HexWallEW, true, false)
  -- freeformparamflags(HexWallSE, true, false)
  -- freeformparamflags(HexWallSW, true, false)

  Stairs = 
    tilemerge4(
      tilefreeform(Stair, Stair1), 
      tilefreeform(Stair, Stair2), 
      tilefreeform(Stair, Stair3), 
      tilefreeform(Stair, Stair4)
      )
  
  Stairs = tilemerge3(Stairs,
    tilefreeform(Stair, Stair5), 
    tilefreeform(Stair, Stair6)
    )

  Stairs = tilespatial(Stairs, spFloor)
  end

tilelayers = {0,1}

function ytileobj(M,x,y)

  global_x = x
  global_y = y
  
  local function hycolor(x) return tilerecolor(x, M.hcolor) end
  
  local out = nil
  local function mergeout(x)
    out = tilemerge(out, x)
    end
  
  local function mergeoutit(x)
    if mode == modeTPP then
      x = simulateSpAuto(x)
      end
    out = tilemerge(out, tilemerge(ShadowD, tilerecolor(x, M.icolor)))
    end
  
  -- choose x for blade colors, y for gem colors, and z for special colors
  local function mergeoutbgo(x,y,z)
    local co = (M.icolor)
    if co == vgaget(8) then 
      mergeoutit(z)
    elseif co == vgaget(4) or co == vgaget(1) or co == vgaget(2) or co == vgaget(5) then 
      mergeoutit(y)
    else 
      mergeoutit(x)
      end
    end

  if M.floor == av("<") then 
    if not uu then uu = 0 end
    local Ceil = tilespatial(tilerecolor(WT[4][uu], 0x181818), spCeil)
    mergeout(Ceil)
    mergeout(tilerecolor(Up, 0xFFFFFFF))
    mergeout(Stairs)
    end
  
  if M.floor == av(">") then 
    if not uu then uu = 0 end
    local Floor = tilespatial(tilerecolor(WT[4][uu], 0x181818), spFloorH)
    mergeout(Floor) 
    mergeout(tilerecolor(DownF, 0xFFFFFFF))
    -- this is possible only in the openGL mode
    if useGL then
      mergeout(tilefreeform(Stairs, MoveDown))
      end
    -- this would require us to disable spFloor
    end
  
  -- blood drops
  
  if M.dead then 
    if violencelevel >= 75 then mergeout(Blood) end
    if violencelevel >= 25 then
      if M.dead < 0 then mergeout(Twinbody)
      elseif M.dead ~= vgaget(1) then mergeout(tilerecolor(Corpse, M.dead))
        end
      end
    end

  -- items
  local function sh(x) return tilemerge(ShadowD, x) end
  
  if M.iicon == av("!") then mergeoutit(Potion)
  elseif M.iicon == av("$") then mergeoutit(Rune)
  elseif M.iicon == av("?") then 
    M.icolor = colormix(M.icolor, 0xFFFFFF)
    mergeoutit(Scroll)
  elseif M.iicon == av("(") then mergeoutit(Sword)
  elseif M.iicon == av(")") then mergeoutit(Mace)
  elseif M.iicon == av("/") then mergeoutit(Divisor)
  elseif M.iicon == av("*") then mergeoutit(Star)
  elseif M.iicon == av("]") then mergeoutit(Shield)
  elseif M.iicon == av("[") then mergeoutit(Prec)
  elseif M.iicon == av("{") then mergeoutit(Dance)
  elseif M.iicon == av("}") then mergeoutbgo(Logger,Bow,Logger)
  elseif M.iicon == av("&") then mergeoutit(Quake)
  elseif M.iicon == av("|") then mergeoutit(Mace)
  elseif M.iicon == av("\\") then mergeoutit(Deco)
  elseif M.iicon == av(";") then mergeoutit(Axe)
  elseif M.iicon == av("-") then mergeoutit(Wand)
  elseif M.iicon == av("+") then mergeoutit(Trident)
  elseif M.itype and M.itype == av("R") then mergeoutit(Erado)
  elseif M.iicon == av("r") then mergeoutbgo(Erado,Erado,Erado)
  elseif M.iicon == av("t") then mergeoutbgo(Erado,Pickaxe,Pickaxe)
  elseif M.iicon == av("^") then mergeoutbgo(Erado,Pickaxe,Pickaxe)
  elseif M.iicon == av("y") then mergeoutbgo(Pickaxe,Pickaxe,Pickaxe)
  elseif M.iicon == av("o") then mergeoutbgo(Disk,Stone,Disk)

  elseif M.iicon == av("a") then mergeoutit(Machete)
  elseif M.iicon == av("b") then mergeoutit(Dagger)
  elseif M.iicon == av("c") then mergeoutit(Nullsector)
  elseif M.iicon == av("d") then mergeoutit(Vorpal)
  elseif M.iicon == av("e") then mergeoutit(GiantBlade)
  elseif M.iicon == av("f") then mergeoutit(Goldcut)
  elseif M.iicon == av("g") then mergeoutit(BladeTrap)
  elseif M.iicon == av("h") then mergeoutit(DivTrap)
  elseif M.iicon == av("i") then mergeoutit(RockTrap)
  elseif M.iicon == av("j") then mergeoutit(Scythe)
  end
  
  -- monsters etc
  
  local al = M.hicon and alnumav(M.hicon)
  local co = M.hcolor

  local function shz(x,y) 
    if inhex then
      if mode == modeISO then
        amsmul = V(.5, .5)
      else
        amsmul = V(.5,1)
        end
    else
      amsmul = V(1,1)
      end

    x = applymoveshift(x, y or "player", true)
    x = sh(x)
    return tilelayer(x, 1)
    end

  local function shn(x) 
    if mode == modeTPP then
      x = simulateSpAuto(x)
      end
    return sh(x)
    end

  if M.gfxid then mergeout(shz(animatedhydras[M.gfxid], M.hid))
  elseif M.hicon == av("@") and not playeralive then mergeout(shz(SlayerDead))
  elseif M.hicon == av("@") and M.hcolor ~= vgaget(13) and mode == modeFPP then 
    -- do not draw the player in FPP (but do in TPP)
    -- but apply move shift
    shz(Slayer)
  elseif M.hicon == av("@") and M.hcolor == vgaget(15) then mergeout(shz(Slayer))
  elseif M.hicon == av("@") and M.hcolor == vgaget(14) then mergeout(shz(SlayerNaga))
  elseif M.hicon == av("@") and M.hcolor == vgaget(12) then mergeout(shz(SlayerCentaur))
  elseif M.hicon == av("@") and M.hcolor == vgaget(11) then mergeout(shz(SlayerTitan))
  elseif M.hicon == av("@") and M.hcolor == vgaget(10) then mergeout(shz(SlayerAtlantean))
  elseif M.hicon == av("@") and M.hcolor == vgaget(13) then 
    mergeout(shz(Twin, "twin"))
  elseif M.hicon == av(" ") then mergeout(tilerecolor(Hydra[7], 0))
  elseif al and al>0 then
    if co == vgaget(8) then mergeout(shn(Mushroom[math.min(al,9)]))
    elseif M.monkey then 
      local m = Monkey[math.min(al,3)]
      if M.monkey == 2 then m = tilemerge(m, MonkeyWpn) end
      mergeout(shz(m, M.hid))
    elseif co == vgaget(1) and al >= 5 then 
      mergeout(shz(Ettin[4], M.hid))
    elseif co == vgaget(1) then 
      mergeout(shz(Ettin[math.min(al,3)], M.hid))
    else 
      mergeout(shz(tilerecolor(Hydra[al], co), M.hid))
    end
  end
  
  -- targets
  if M.target then mergeout(shn(tilerecolor(Target, vgaget(12)))) end

  if M.stun then mergeout(stunanim[M.stun][math.floor(getticks()/10) % 100]) end
  
  return out
  
  end

stunanim = {}

GoldenStar = tilerecolor(TinyStar, vgaget(14))
for st=1,7 do
  stunanim[st] = {}
  for tu=0,99 do
    local frame = nil
    for u=1,st do
      local t = math.pi*2*(u/st + tu/100)
      frame = tilemerge(frame, tilexf(GoldenStar, 
        (14 + 14 * math.sin(t))/32, (4+4* math.cos(t))/32, 5/32, 5/32,
        math.cos(t)/2, 0
        ))
      end
    stunanim[st][tu] = tilespatial(frame, spFlat + spIItem + spMonst)
    end
  end

function xinventory(C)
  local ch = gch(C)
  local co = gco(C)
  local function rec(x) return tilerecolor(x, co) end

  if ch == ("!") then return rec(Potion)
  elseif ch == ("$") then return rec(Rune)
  elseif ch == ("?") then return rec(Scroll)
  else return C end
  end

tm_inventory = newmapping(xinventory)

function bloody(x)
  if violencelevel >= 75 then return tilemerge(Blood, x)
  elseif violencelevel >= 25 then return x
  else return nil
  end end
  
function xtileobj(C)

  if gp2(C) == nil then return nil end
  
  local ch = gch(C)
  local co = gco(C)
  local function rec(x) return tilerecolor(x, co) end
  
  -- choose x for blade colors, y for gem colors, and z for special colors
  local function bgo(x,y,z)
    if co == vgaget(8) then 
      return z
    elseif co == vgaget(4) or co == vgaget(1) or co == vgaget(2) or co == vgaget(5) then 
      return y
    else 
      return x
      end
    end

  al = alnum(ch);

  -- blood drops

  if ch == ("%") and co ~= vgaget(8) then return bloody(rec(Corpse))
  elseif ch == ("@") and co == vgaget(12) then return bloody(Twinbody)
  
  -- 2: monsters etc
  
  elseif ch == "@" and co == vgaget(15) then return Slayer
  elseif ch == "@" and co == vgaget(13) then return Twin
--  elseif ch == "@" and co == vgaget(12) then return Twinbody
--  elseif ch == "%" then return rec(Corpse)
  elseif al > 0 then
    if co == vgaget(8) then return Mushroom[math.min(al,9)]
    elseif co == vgaget(2) then return rec(Mushroom[math.min(al,9)])
    elseif co == vgaget(1) then return rec(Ettin[math.min(al,3)])
    else return rec(Hydra[al])
    end
  
  -- 3: walls etc
  elseif ch == ("#") and co == vgaget(12) then return rec(Target) 
  elseif ch == (">") then return rec(Down)
  elseif ch == ("<") then return rec(Up)
  
  -- 4: items etc
  elseif ch == ("!") then return rec(Potion)
  elseif ch == ("$") then return rec(Rune)
  elseif ch == ("?") then return rec(Scroll)
  elseif ch == (":") then return rec(Target)
  elseif ch == (".") and co == vgaget(12) then return rec(Target)
  elseif ch == ("(") then return rec(Sword)
  elseif ch == (")") then return rec(Mace)
  elseif ch == ("/") then return rec(Divisor)
  elseif ch == ("*") then return rec(Star)
  elseif ch == ("]") then return rec(Shield)
  elseif ch == ("[") then return rec(Prec)
  elseif ch == ("{") then return rec(Dance)
  elseif ch == ("}") then return rec(bgo(Logger,Bow,Logger))
  elseif ch == ("&") then return rec(Quake)
  elseif ch == ("|") then return rec(Mace)
  elseif ch == ("\\") then return rec(Deco)
  elseif ch == (";") then return rec(Axe)
  elseif ch == ("-") then return rec(Wand)
  elseif ch == ("+") then return rec(Trident)
  elseif ch == ("^") then return rec(bgo(Erado,Pickaxe,Pickaxe))
  elseif ch == ("r") then return rec(Erado)
  elseif ch == ("y") then return rec(Pickaxe)
  elseif ch == ("o") then return rec(bgo(Disk,Stone,Disk))
  else return nil
  end
  end

function xtileold(C,x,y)
  local xtf = xtilefloor(C)
  uu = (x+3*y) % 5
  checker = 0
  -- congratulations, you have found the hidden checkerboard!
  -- just remove the -- from the next line
  -- checker = ((x+y)%2) * (0x101010)
  floorcolor = 0x805050 - checker
  if xtf == Lightfloor then
    xtf = 
      tilemerge(
        tilespatial(tilerecolor(WT[10][uu], floorcolor), spFlat + spFloorH + spIFloor),
        tilespatial(tilerecolor(WT[4][uu], 0x203020), spCeil)
        )
  elseif xtf == Darkfloor then
    xtf = tilespatial(tilerecolor(WT[10][uu], 0x202020 - checker/2), spFlat + spFloorH + spIFloor)
    -- ceiling should not be visible, so we just don't draw it
  elseif xtf == Wall then
    local wall = tilerecolor(WT[6][uu], 0x503030)
    xtf = tilespatial(wall, spFlat + spWall + spIWall + spICeil)
    xtf = tilemerge(xtf, tilespatial(tiletransform(wall, 1, 0, -1, 0), spCeil))
    end
  return tilemerge(xtf, xtileobj(C))
  end

til = newimage(32,32)
for x=0,31 do for y=0,31 do setpixel(til,x,y,0x3000003 * (x+y)) end end
til = addtile(til, 0, 0, 32, 32, transAlpha)

shadtable = {}

for shad=0,15 do
  local ytf = nil
  if bAND(shad, 1) > 0 then ytf = tilemerge(ytf, ShadowE) end
  if bAND(shad, 2) > 0 then ytf = tilemerge(ytf, ShadowW) end
  if bAND(shad, 4) > 0 then ytf = tilemerge(ytf, ShadowS) end
  if bAND(shad, 8) > 0 then ytf = tilemerge(ytf, ShadowN) end
  shadtable[shad] = ytf
  end

function xtile(C,x,y)
  if oldhydra then return xtileold(C,x,y) end
  global_x = x
  global_y = y
  
  if inhex and (mode == modeFPP or mode == modeTPP) then
    if (x+y)%2 == 1-inhexr then return nil end
    local M = hydramap(x,y,mode)
    local R0 = 
      oldhydra and xhex(C) or yhex(M)
    local R = R0
    if R0 == FloorHex or R0 == DarkfloorHex then
      R = tiletransform(R, -1, -0.25, 3, 1.5)
      R = tilemerge(R, tilefreeform(tilerecolor(R, 0x008000), GotoRoof))
      R = tilespatial(R, spFree)
      end
    if R0 == WallHex or R0 == DarkwallHex then
      if R0 == DarkwallHex then 
        R = tilerecolor(WT[6][0], 0x202020)
      else
        R = tilerecolor(WT[6][0], 0x503030)
        end
      local R1 = tilefreeform(R, HexWallEW)
      local R2 = tilefreeform(R, HexWallSW)
      local R3 = tilefreeform(R, HexWallSE)
      local RTop = tiletransform(R0, -1, -0.25, 3, 1.5)
      R = tilespatial(tilefreeform(RTop, GotoRoofTop), spFree)
      R = tilemerge3(R, tilespatial(R1, spWallE + spWallW), tilespatial(
        tilemerge(R2, R3), spWallN + spWallS))
      end
    R = tilemerge(R, oldhydra and xtileobj(C) or ytileobj(M,x,y))
    return R
    end
  
  local M = hydramap(x,y,mode)
  if M.out == 1 then
    return OutOfMap
    end
  if M.cached then 
    return noteye_by_handle(M.cached)
    end
  local ytf = ytilefloor(M)
  local uu = M.uu
  checker = 0
  floorcolor = 0x504040 - checker
  if ytf == Lightfloor then
    ytf = 
      tilemerge(
        tilespatial(tilerecolor(WT[10][uu], floorcolor), spFlat + spFloorH + spIFloor),
        tilespatial(tilerecolor(WT[4][uu], 0x203020), spCeil)
        )
  elseif ytf == Wall then
    local wall = tilerecolor(WT[6][uu], 0x503030)
    -- wall = tiletransform(wall, -1, 1, 1, 0)
    ytf = tilespatial(wall, spFlat + spWall + spIWall + spICeil + spWallTop + spWallBot)
    end
  if (not M.seen) and ytf ~= Unseen then 
    ytf = tilerecolor(ytf, 0x202020)
    end
  --if bAND(M.shadow, 1) > 0 then ytf = tilemerge(ytf, ShadowE) end
  --if bAND(M.shadow, 2) > 0 then ytf = tilemerge(ytf, ShadowW) end
  --if bAND(M.shadow, 4) > 0 then ytf = tilemerge(ytf, ShadowS) end
  --if bAND(M.shadow, 8) > 0 then ytf = tilemerge(ytf, ShadowN) end
  ytf = tilemerge(ytf, shadtable[bAND(M.shadow, 15)])
  ytf = tilemerge(ytf, ytileobj(M,x,y))
  if M.cacheid and not inhex then hydracache(M.cacheid, noteye_assign_handle(ytf)) end
  if M.animation then ytf = tilemerge(ytf, noteye_by_handle( M.animation )) end
  return ytf
  end

function xminimap(C)
  b = 0
  local ch = gch(C)
  local co = gco(C)
  al = alnum(ch)
  
  if gp2(C) == nil or ch == (" ") or (ch == (".") and co == vgaget(12)) then b=0x181810
  elseif ch == (".") or ch == (":") then b = 0x8404040
  elseif ch == ("#") then b = 0xC0C0C0
  elseif ch == ("%") then b = 0x8604040
  elseif al > 0 and co == vgaget(8) then b = 0x2F08000
  elseif al > 0 then b = 0xFF0000
  elseif ch == (">") or ch == ("<") then b = 0xFF00FF
  elseif ch == ("@") then b = 0xFFFFFF
  elseif ch == ("!") or ch == ("$") or ch == ("?") then b = 0x00FF00
  else b = 0x0000FF
  end
  
  return tilefill(b)
  end

tm_minimap = newmapping(xminimap)

function ispc(C)
  return gch(C) == "@" and gco(C) == vgaget(15)
  end

function centerwhere()
  if curcoords and curcoords.twinx and mode ~= modeFPP then
    return V((curcoords.scrx+curcoords.twinx)/2, (curcoords.scry+curcoords.twiny)/2)
  else
    return playerpos
    end
  end

function findpc()
  local lastcoords = curcoords
  curcoords = hydracoords()
  ncursor = V(curcoords.scrx, curcoords.scry)
  mapon = pcat(ncursor)
  
  if not lastcoords then lastcoords = curcoords end

  local shiftvec = V(
    (curcoords.intx - curcoords.scrx) - (lastcoords.intx - lastcoords.scrx),
    (curcoords.inty - curcoords.scry) - (lastcoords.inty - lastcoords.scry)
    )
  
  if topx ~= curcoords.topx or topy ~= curcoords.topy then
    topx = curcoords.topx
    topy = curcoords.topy
    prepareconsole()
    end

  if shiftvec.x ~= 0 or shiftvec.y ~= 0 then
    if mapcenter then mapcenter = mapcenter - shiftvec end
    if oplayerpos then oplayerpos = oplayerpos - shiftvec end
    for k,v in pairs(moveanimations) do
      if v.animxy then v.animxy = v.animxy - shiftvec end
      end
    end
  
  end

function calc_realmap(t)
  D.realmapshift = V(0,0)
  if topx and topx ~= 0 then
    D.realmapshift.x = D.map.size.x
    end
  if topy and topy ~= 0 then
    D.realmapshift.y = D.map.size.y
    end
  D.realmapsize = D.map.size + D.realmapshift * 2
  end

playeralive = true

function checkdeath()
  if oldhydra then
    local lch = scrget(IMG, 51, 9)
    if gch(lch) ~= "L" then lch = scrget(IMG, 51, 10) end
    if gch(lch) == "L" then 
      local lco = gco(lch)
      if lco == vgaget(15) then 
        --print("alive")
        playeralive = true
      elseif lco == vgaget(12) then 
        --print("barely")
        playeralive = true
      elseif lco == vgaget(4) then 
        if playeralive then 
          musichalt()
          end
        playeralive = false
        --print("dead")
      end
      end
  else
    playeralive = curcoords and curcoords.hitpoints and curcoords.hitpoints > 0
    end
  end

do local oldcopymap = copymap
function copymap()
  oldcopymap()
  
  checkdeath()
  
  if mapon then
  
    ininv = string.find(getline(0), "Inventory")

    -- change to icons
    if ininv and mode ~= modeASCII then
      scrcopy(IMG, 53, 5, IMG, 53, 5, 1, 19, tm_inventory)
      end
    
    -- move hydra stats to the top left corner
    if (mode == modeFPP or mode == modeTPP) and not ininv then
      if gch(scrget(IMG, 51, 9)) == "L" then
        topy = 9
      else
        topy = 10
        end
      scrcopy(IMG, 50, topy, IMG, 0, 0, 30, 11, TMAP_COPY)
      scrcopy(IMG, 50, 11, IMG, 0, 1, 30, 11, TMAP_COPY)
      scrfill(IMG, 50, topy, 30, 22-topy, nil)
      end

    -- we need to check if we are in the hex mode
    inhex0 = true
    inhex1 = true
    for x=1,50 do 
      for y=1,22 do
        local c = gch(scrget(MAP,x,y))
        if av(c) ~= 0 and av(c) ~= 255 and c ~= " " and (c < "0" or c > "9") and c ~= "*" and c ~= "Z" then
          if (x+y)%2 == 1 then
            inhex0 = false
          else
            inhex1 = false
            end
          end
        end
      end
    inhex = inhex0 or inhex1
    inhexr = inhex1 and 1 or 0
    gamehexdir = inhex
    gamefourdir = (not gamehexdir) and hydraDIRS and hydraDIRS() == 4
    end
  end
end

function drawBackgroundAndMap()
  if not imagebackgrounds then 
    if mapon then return drawMap() 
    else return axOpaque end
    end
  local curscr = getline(0)
  local curscr1 = getline(1)
  if string.find(curscr, "About") then
    V.drawtile(D.output, Lightfloor, D.rscreen)
    V.drawtile(D.output, xtileobj(scrget(S, 0, 0), 0,0), rectCS(D.rscreen.ctr, V(D.rscreen.size.y, D.rscreen.size.y)))
    V.drawtile(D.output, tileshade(0), D.rscreen)
    V.drawtile(D.output, tileshade(0), D.rscreen)
    return axTransparent
  elseif string.find(curscr, "Welcome") 
    or string.find(curscr1, "Select your race") 
    or string.find(curscr, "Hki") 
    or string.find(curscr, "Hydra Slayer") 
    or string.find(curscr, "achievement") or string.find(curscr, "Cheats")
    or (mode == modeMini and not mapon)
  then
    V.drawtile(D.output, HydraTitleTile, D.rscreen)
    V.drawtile(D.output, tileshade(0), D.rscreen)
    V.drawtile(D.output, tileshade(0), D.rscreen)
    return axTransparent
  elseif not mapon then
    V.drawtile(D.output, HydraTitleTile, D.rscreen)
    V.drawtile(D.output, tileshade(0), D.rscreen)
    V.drawtile(D.output, tileshade(0), D.rscreen)
    return axTransparent
    end
  return drawMap()
  end

GermaniaOne = newttfont("gfx/GermaniaOne-Regular.ttf")

axTransparentUgly = {nil, nil, tmap_transorshade}

do local drat = drawAscii
function drawAscii(ax)

  -- do return end
  if ax == axSemitransparent then
    local X = screen.top.x
    local Y = screen.top.y
    local ssx = screen.size.x
    local ssy = screen.size.y
    
    local sh = tileshade(vgaget(0))

    if not mapon then
      return
      end
    
    if ininv then
      drawtile(D.output, sh, X+50*fontsize.x, Y, 30*fontsize.x, fontsize.y*24)
      -- drawtile(D.output, tileshade(0), 50*fontsize.x, scrsize.y-3*24, scrsize.x-3*52-50*8, 344-(scrsize.y-3*24))
    
    elseif mode == modeFPP or mode == modeTPP then
      cursor = nil
      ysize = 1
      while gch(scrget(IMG, 0, ysize)) ~= " " and av(gch(scrget(IMG, 0, ysize))) ~= 0 do
        ysize = ysize + 1
        end
      drawtile(D.output, sh, X, Y, 30*fontsize.x, ysize*fontsize.y)
      
      ysize = 2
      while ysize < 10 and (gch(scrget(IMG, 51, ysize)) ~= " " or gch(scrget(IMG, 52, ysize)) ~= " ") do
        ysize = ysize + 1
        end
      drawtile(D.output, sh, X+50*fontsize.x, Y, 30*fontsize.x, ysize*fontsize.y)
    
    else
      drawtile(D.output, sh, X+50*fontsize.x, Y, xscreen.size.x-X-50*fontsize.x, ssy-3*fontsize.y)
      -- drawtile(D.output, sh, X+50*fontsize.x, Y+22*fontsize.y, scrsize.x-3*52-50*8, fontsize.y*3)
      end

    drawtile(D.output, sh, X, Y+22*fontsize.y, ssx, fontsize.y*3)
    
    --profstart("drat")
    drat(axTransparentUgly)
    --profend("drat")
  
  else
    drat(ax)
    end

  end
end

function drawtrailer()
  if trailer then

    local function afun(x)
      if x > 1000 then return 0xFFFFFF end
      return math.floor(255 * (x/1000)) * 0x10101
      end

    local t = getticks() - trailer.at
    
    print("phase = "..trailer.phase)
    
    if t < 1000 and trailer.phase == 1 then 
      drawtile(Gfx, tilealpha(0, afun(t)), 0, 0, xscrsize.x, xscrsize.y)
    
    elseif trailer.phase == 10 then 
      V.drawtile(D.output, HydraTitleTile, D.rscreen)
    
    elseif t < 1000 and trailer.phase == 11 then
      V.drawtile(D.output, HydraTitleTile, D.rscreen)
      drawtile(Gfx, tilealpha(0, afun(t)), 0, 0, xscrsize.x, xscrsize.y)
      
    elseif trailer.phase == 1 or trailer.phase == 11 then 
      trailer.phase = 2
      nsendtext("Z")
      drawtile(Gfx, tilefill(0), 0, 0, xscrsize.x, xscrsize.y)
    
    elseif trailer.phase == 2 and t < 1100 then
      drawtile(Gfx, tilefill(0), 0, 0, xscrsize.x, xscrsize.y)
    
    elseif trailer.phase == 2 then
      local function untrail(x)
        while x ~= "" and x:sub(x:len()) == " " do
          x = x:sub(1, x:len()-1)
          end
        return x
        end
      
      msg1 = untrail(readline(S, 0, 80, 22))
      msg2 = untrail(readline(S, 0, 80, 23))
      trailer.phase = 3

      drawtile(Gfx, tilefill(0), 0, 0, xscrsize.x, xscrsize.y)
    
    elseif trailer.phase == 3 then
      -- draw the texts
      drawtile(Gfx, tilefill(0), 0, 0, xscrsize.x, xscrsize.y)
      
      local a = t - 1100
      a = math.floor(a/2)
      if a > 255 then a = 255 end
      a = a * 0x1000000 + 0xFFD500

      renderlongtext(GermaniaOne, 50,
        "\v*ac\n" .. msg1 .. "\n" .. msg2,
        a, Gfx, 
        rectXY(xscrsize.x/4, xscrsize.y/4, xscrsize.x*3/4, xscrsize.y)
        )
    
    elseif trailer.phase == 4 then
      local a = t
      a = math.floor(a/2)
      if a > 255 then a = 255 end
      a = 255 - a
      a = a * 0x1000000 + 0xFFD500

      local u = 1000-t
      if u<0 then u=0 end

      drawtile(Gfx, tilealpha(0, afun(u)), 0, 0, xscrsize.x, xscrsize.y)

      renderlongtext(GermaniaOne, 50,
        "\v*ac\n" .. msg1 .. "\n" .. msg2,
        a, Gfx, 
        rectXY(xscrsize.x/4, xscrsize.y/4, xscrsize.x*3/4, xscrsize.y)
        )

      if t > 1000 then trailer = nil end
      end
    
    end

  end


gotup = false lmodup = modup
gotdn = false lmoddn = moddn

function modup(ev) return (inhex and mapon and gotup) or lmodup(ev) end
function moddn(ev) return (inhex and mapon and gotdn) or lmoddn(ev) end

-- don't rotate in ISO hex!
lsendrotated = sendrotated

function sendrotated(ev)
  if iskey(ev, KEYS.UP) or iskey(ev, KEYS.KP_8) then 
    gotup = ev.type == evKeyDown
    end
  if iskey(ev, KEYS.DOWN) or iskey(ev, KEYS.KP_2) then 
    gotdn = ev.type == evKeyDown
    end
  if mode == modeISO and inhex then
    mode = modeASCII
    lsendrotated(ev)
    mode = modeISO
  else
    lsendrotated(ev)
    end
  end

clickmouse = function (ev) end

function mousesendsym(sym, msg)
  clickmouse = function () 
    local ev = {}
    ev.type = evKeyDown
    ev.scancode = sym.scancode
    ev.keycode = sym.keycode
    ev.mod = 0
    nsendkey(ev)
    end
  mousemsg = msg
  end

function mousenem(msg)
  clickmouse = function () 
    noteyemenu()
    end
  mousemsg = msg
  end

function mousesendskey(ch, msg)
  mousesendsym(av(ch), msg)
  end

function mousesendstext(t, msg)
  clickmouse = function () 
    nsendtext(t)
    end
  mousemsg = msg
  end

function playerpos_center()
  if inhex and (mode == modeMini or mode == modeMed) then return playerpos + V(1,0.5)
  elseif inhex and mode == modeTiles then return playerpos + V(1.5,0.5)
  else return playerpos + 0.5
  end
  end

do local lvectodir = vectodir
function vectodir(v, mzero)
  if inhex and math.abs(v.x) < math.abs(v.y) then
    local ay = math.abs(v.y)
    return lvectodir(V(v.x > 0 and ay or v.x < 0 and -ay or 0, v.y), mzero) 
  else
    return lvectodir(v, mzero)
    end
  end
end

do local lpixeltodir = pixeltodir
function pixeltodir(v)
  if inhex and mode ~= modeFPP and mode ~= modeTPP and hexround(pixeltoprocess(v)) == playerpos then
    return -1
  else
    return lpixeltodir(v)
    end
  end
end

function checkmouse(ev)
  local d
  
  unclickmouse = function(ev) end
  
  if ev.y >= screen.bot.y-fontsize.y then
    mousemsg = ""
    return
    end
  
  local my = math.floor((ev.y - screen.top.y) / fontsize.y)
  local mx = math.floor((ev.x - screen.top.x) / fontsize.x)

  if string.find(getline(0), "Inventory") then
    mousesendstext("i", "Click to view and use the item")
    local ch = gch(scrget(S, 51, my))
    -- print("my = "..my.." ch = "..tostring(ch))
    if ch ~= "Y" and ch ~= "I" and ch ~= " " and KEYS[ch] then
      clickmouse = function (ev)
        nsendtext(ch)
        end
      end
    return
    end

  if string.find(getline(23), "(y/n)") then
    mousemsg = "Left click for YES, right click for NO"
    clickmouse = function (ev)
      if ev.button > 1 then
        nsendtext("n")
      else
        nsendtext("y")
        end
      end
    return
    end
  
  if not mapon then

    if string.find(getline(0), "description") then
      mousesendstext(" ", "")
      local ch = gch(scrget(S, 0, my))
      if ch ~= "V" and ch ~= " " then
        mousesendstext(ch, "click for information")
        end
      return
      end

    if string.find(getline(0), "the material") then
      mousesendstext(" ", "")
      local ch = gch(scrget(S, 0, my))
      if ch ~= "S" and ch ~= " " then
        mousesendstext(ch, "click to select")
        end
      return
      end

    if string.find(getline(0), "Wounds caused by") then
      mousesendstext(" ", "click here to exit this screen")
      if mx < 20 then
        mousesendstext("-", "click for less heads")
        end
      if mx > 60 then
        mousesendstext("+", "click for more heads")
        end
      return
      end

    if string.find(getline(my), "Press Enter to start playing") then
      mousesendstext("\n", "start playing")
      return
      end

    if string.find(getline(1), "Select your race") then
      mousesendstext("z", "")
      while mx >= 0 do
        local ch = gch(scrget(S, mx, my))
        local col = gco(scrget(S, mx, my))
        if col == vgaget(14) then
          mousesendstext(string.lower(ch), "Click to select this race")
          break
          end
        if gch(scrget(S, mx+1, my)) == ")" then
          mousesendstext(string.lower(ch), "Click to select this option")
          break
          end
        mx = mx - 1
        end
      return
      end

    if string.find(getline(0), "Hydra Slayer") then
      mousesendstext(" ", "")
      if my == 21 and mx >= 40 then
        mousenem("NotEye's sound and visual options")
        return
        end
      local ch0 = gch(scrget(S, 2, my))
      local ch1 = string.lower(gch(scrget(S, 3, my)))
      if ch0 == "(" and ch1 == "f" and gch(scrget(S, 4, my)) == "4" then
        mousenem("NotEye's sound and visual options")
      elseif ch0 == "("  then
        mousesendstext(ch1, "Click to select this option")
        end
      return
      end
    
    if string.find(getline(0), "Random/Daily") then
      mousesendstext(" ", "")
      local ch0 = gch(scrget(S, 2, my))
      local ch1 = string.lower(gch(scrget(S, 3, my)))
      if ch0 == "("  then
        mousesendstext(ch1, "Click to select this option")
        end
      return
      end
    
    if(string.find(getline(0), "Cheats")) then
      if my < 9 then mousesendstext("a", "Use Auto-attack")
      elseif my < 17 then mousesendstext("b", "Allow backups")
      elseif my < 21 then mousesendstext("c", "Cancel this menu")
      else mousesendstext("d", "Restart in debug mode")
      end
      end      

    if(string.find(getline(0), "achievements")) then
      my = math.floor(ev.y / fontsize.y)
      if my < 2 then mousesendsym(KEYS.RETURN, "Exit")
      elseif my >= 22 then mousesendsym(KEYS.RETURN, "Exit")
      elseif my < 12 then mousesendsym(KEYS.PAGEUP, "page up")
      elseif my >=12 then mousesendsym(KEYS.PAGEDOWN, "page down")
      end
      return
      end

    if string.find(getline(0), "sort order") then
      -- troll inventory
      if my == 23 then
        local ch = gch(scrget(S, mx, my))
        mousesendstext(ch, "Store under "..ch)
        return
        end
      if my == 0 and mx > 48 then
        local ch = gch(scrget(S, mx, my))
        if av(ch) >= av("A") and av(ch) <= av("Z") then
          mousesendstext(string.char(av(ch)-64), "Change sort order ("..ch..")")
          return
          end
        end
      while my > 0 and mx >= 0 do
        local ch = gch(scrget(S, mx,my))
        if my >= 2 and my < 22 and gco(scrget(S, mx, 22)) == vgaget(0) 
--      
--      gco(scrget(S, mx, my)) == vgaget(8) and gch(scrget(S,mx+1,my)) == " "
--        and gch(scrget(S,mx+2,my)) ~= " " 
          and ch ~= " " 
--        and (mx == 0 or gch(scrget(S,mx-1,my)) == " ") 
          then
          mousesendstext(ch, "Take this item ("..ch..")")
          clickmouse = function (eva) 
            if eva.button > 1 then nsendtext(string.char(av("v")-96)) end
            nsendtext(ch)
            end
          return
          end
        mx = mx - 1
        end
      end

    -- if string.find(getline(0), 11) the
    if string.find(getline(12), "Enter to get help") then
      -- first page of Help
      mousesendsym(KEYS.RETURN, "Click to see the next page of Help")
      return
      end

    if string.find(getline(my), "'i' for inventory") then
      mousesendstext("i", "Click to see your inventory")
      return
      end

    if string.find(getline(0), "Hki") then
      -- high scores
      mousesendstext(" ", "")
      if my > 0 and my < 10 then
        mousesendsym(KEYS.PAGEUP, "scroll up")
      elseif my >= 10 and my <= 18 then
        mousesendsym(KEYS.PAGEDOWN, "scroll down")
      else while mx >= 0 do
        local ch = gch(scrget(S, mx, my))
        if ch ~= string.lower(ch) then
          mousesendstext(string.lower(ch), "Click to select option "..ch)
          break
          end
        mx = mx - 1
        end
        end
      return
      end

    return
    end
  
  if mx >= 50 and my < 10 then
    clickmouse = function (eva) 
      if eva.button > 1 then hydrainfo(100, my) return end
      nsendtext(string.sub("1234567890", my+1, my+1)) 
      end
    mousemsg = "Click to change your weapon (digits)"
    return
    end

  if my >= 22 and ev.x < rscreen.bot.x - 52 * minimapsize.x then
    mousesendstext("m", "Click to view last messages ('m')")
    return
    end

  if mx >= 50 and mode ~= modeFPP and ev.y < rscreen.bot.y - 22 * minimapsize.y then
    mousesendstext("f", "Click to get more information about hydras in sight ('f')")
    clickmouse = function (ev) 
      if ev.button > 1 then hydrainfo(100, my) return end
      nsendtext("f")
      end
    return
    end

  if mx < 30 and my < 1 and (mode == modeFPP or mode == modeTPP) then
    mousesendstext("f", "Click to get more information about hydras in sight ('f')")
    return
    end
  
  if cmini and inrect(ev, cmini) then
    mousemsg = "Scroll the map"
    return
    end

  local d = pixeltodir(V.be(ev))
  
  -- if (d == 2 or d == 6) and inhex then d = -2 end
  
  if d >= 0 then
    local k = dirkeys[d]
    if mode == modeISO and not inhex then
      -- we need to prevent sendrotated from rotating us
      k = dirkeys[(7+d)%8]
      end
    ev.mod = 0
    ptp = hexround(pixeltoprocess(ev))
    clickmouse = function (eva)
      if mode == modeFPP or mode == modeTPP then
        eva.scancode = 0
        eva.keycode = 0
        eva.mod = 0
        eva.type = 0
        eva.type = evKeyBoth
        rotatekey_dir(eva, d, 8)
        nsendkey(eva)
      elseif eva.button > 1 and hydrainfo then
        evb = hexround(pixeltoprocess(eva))
        hydrainfo(evb.x, evb.y)
      else
        evb = hexround(pixeltoprocess(eva))
        if hsmousepath then hydraqueuetarget(evb.x, evb.y) end
        nsendkey2(k, evKeyBothText)
        end
      end
    if mode ~= modeFPP and mode ~= modeTPP then
      local dirnames = {"E ", "NE", "N ", "NW", "W ", "SW", "S ", "SE"}
      ptp2 = hexround(ptp)
      mousemsg = "L = move or attack "..dirnames[d+1]..(hydrainfo and " R = info: "..
        hydralook(ptp.x, ptp.y) or "")
    else
      local dirnames = {"move right", "turn right", "go forward", "turn left", "go left", "turn left", "go backward", "turn right"}
      mousemsg = "Click to "..dirnames[d+1]
      end
  else
    clickmouse = function (ev) 
      ev.type = evKeyDown
      ev.mod = 0
      if ev.button > 1 and d == -2 and hydrainfo then
        evb = hexround(pixeltoprocess(ev))
        hydrainfo(evb.x, evb.y)
        return
      elseif ev.button > 1 then
        nsendtext("g")
      else
        nsendtext(".")
        end
      end
    mousemsg = "Left click = wait ('.'), right = pick up / use stairs ('g')"
    if d == -2 and hydrainfo then
      mousemsg = "Left click = wait ('.'), right = info"
      end
    end
  end

local lsendmouse = handlemouse2

havetrailer = true

function invoke_trailer()
  if trailer and trailer.phase == 3 then
    trailer = {at = getticks(), phase = 4}
  elseif trailer and trailer.phase == 1 then
    trailer = {at = getticks(), phase = 10}
  elseif trailer and trailer.phase == 10 then
    trailer = {at = getticks(), phase = 11}
  else
    trailer = {at = getticks(), phase = 1}
    end
  end

function handlemouse2(ev)
  if hsmousecfg == 3 then return end
  mousepos = V.be(ev)
  
  if ctrlpressed() then
    lsendmouse(ev)
    return
    end
  
  if ev.type == evMouseMotion then
    scrollmanual = true
    lastmm = ev
  elseif ev.type == evMouseDown and clickmouse then
    clickmouse(ev)
  elseif ev.type == evMouseUp and unclickmouse then
    unclickmouse(ev)
    end
  end

function loadheximages()
  if not FloorHex then
    -- no need for spatial flags since hex 3D not supported yet
    FloorPNG = loadimage("gfx/hexfloor.png")
    FloorHex = addtile(FloorPNG, 0, 0, 48, 48, 0)
    WallPNG = loadimage("gfx/hexwall.png")
    WallHex = addtile(WallPNG, 0, 0, 48, 48, 0)
    DarkfloorHex = tilerecolor(FloorHex, 0x8000000)
    DarkwallHex = tilerecolor(WallHex, 0x606060)
    BlackHex = tilecol(WallHex, 0, recMult)

    FloorIsoI = newimage(48, 48)
    drawtile(FloorIsoI, FloorHex, 0, 24, 48, 24)
    FloorIso = addtile(FloorIsoI, 0, 0, 48, 48, 0)
    DarkFloorIsoI = newimage(48, 48)
    drawtile(DarkFloorIsoI, DarkfloorHex, 0, 24, 48, 24)
    DarkFloorIso = addtile(DarkFloorIsoI, 0, 0, 48, 48, 0)
    TempImg = newimage(32, 32)
    drawtile(TempImg, tilerecolor(WT[7][0], 0x504040), 0, 0, 32, 32)
    WallIsoI = newimage(48, 48)
    for x=0,16 do for y=0,24 do
      setpixel(WallIsoI, x+8, y+16+x/2, getpixel(TempImg, x*2, y*4/3))
      end end
    drawtile(TempImg, tilerecolor(WT[7][0], 0x706060), 0, 0, 32, 32)
    for x=0,16 do for y=0,24 do
      setpixel(WallIsoI, x+8+16, y+24-x/2, getpixel(TempImg, x*2, y*4/3))
      end end
    for x=0,48 do for y=0,24 do
      if getpixel(WallPNG,x,y*2) ~= 0 then setpixel(WallIsoI, x, y, 0x10101 * math.floor(16 + 16 * math.random())) end
      end end
    WallIso = addtile(WallIsoI, 0, 0, 48, 48, 0)
    end
  end

function xhex(C)

  local c = xtilefloor(C)
  
  if c == Wall then return WallHex
  elseif c == Lightfloor then return FloorHex
  elseif c == Darkfloor then return DarkfloorHex
  else return BlackHex
    end
  end

function yhex(M)

  local c = ytilefloor(M)
  
  if c == Wall then
    return M.seen and WallHex or DarkwallHex
  elseif c == Lightfloor then
    return M.seen and FloorHex or DarkfloorHex
  else return BlackHex
    end
  end

function xiso(C)

  local c = xtilefloor(C)

  if c == Wall then return WallIso
  elseif c == Lightfloor then return FloorIso
  elseif c == Darkfloor then return DarkFloorIso
  else return OutOfMap
    end
  end

function yiso(M)

  local c = ytilefloor(M)
  
  if c == Wall then 
    return M.seen and WallIso or tilerecolor(WallIso, 0x101010)
  elseif c == Lightfloor then 
    return M.seen and FloorIso or tilerecolor(FloorIso, 0x202020)
  else return nil
    end
  end

-- hydraget(x,y) = scrget(MAP, x, y)

function hex_drawdisplayMini()

  loadheximages()
  
  playerat = {
    x = (playerpos.x+1) * fontsize.x, y = (playerpos.y+0.5) * fontsize.y
    }
  
  for x=0,map.size.x-1 do for y=0,map.size.y-1 do if ((x+y)%2 == inhexr) then
    drawtile(D.output, oldhydra and xhex(scrget(MAP, x, y)) or yhex(hydramap(x, y, mode)),
      screen.top.x + x * fontsize.x - fontsize.x/2, 
      screen.top.y + y * fontsize.y - fontsize.y/4, 
      fontsize.x * 3, fontsize.y * 1.5
      )
    end end end
    
  for x=0,map.size.x-1 do for y=0,map.size.y-1 do if ((x+y)%2 == inhexr) then
    drawtile(D.output, oldhydra and xtileobj(scrget(MAP, x, y)) or ytileobj(hydramap(x, y, mode),x,y),
      screen.top.x + x * fontsize.x, 
      screen.top.y + y * fontsize.y, 
      fontsize.x * 2, fontsize.y
      )
    end end end
  return false
  end

function hex_drawdisplayTiles()
  
  -- this is useless with a 16x32 font
  --if fontsize.x == 16 and fontsize.y == 32 and mapon then
  --  hex_drawdisplayMini()
  --  return
  --  end
  
  setmaparea()
  settilectr()
  tilesize.x = tilesize.x / 2
  recentermap()

  loadheximages()
  local mcf = V.floor(mapcenter)
  tcs = tilectr - (mapcenter - mcf) * tilesize
  
  dx0 = -math.ceil((tcs.x - maparea.top.x + 3*tilesize.x) / tilesize.x)
  dx1 = math.ceil((maparea.bot.x - tcs.x) / tilesize.x)
  dy0 = -math.ceil((tcs.y - maparea.top.y + 3*tilesize.x) / tilesize.y)
  dy1 = math.ceil((maparea.bot.y - tcs.y) / tilesize.y)
  
  for dx=dx0,dx1 do for dy=dy0,dy1 do if((dx+dy+mcf.x+mcf.y)%2 == inhexr) then
    drawtile(D.output,
      oldhydra and xhex(scrget(MAP, mcf.x+dx, mcf.y+dy)) 
      or yhex(hydramap(mcf.x+dx, mcf.y+dy, mode)),
      tcs.x + (dx-1.5) * tilesize.x, tcs.y + (dy-.75) * tilesize.y, tilesize.x*3, tilesize.y*1.5)
    end end end

  for dx=dx0,dx1 do for dy=dy0,dy1 do if((dx+dy+mcf.x+mcf.y)%2 == inhexr) then
    drawtile(D.output,
      oldhydra
      and xtileobj(scrget(MAP, mcf.x+dx, mcf.y+dy), mcf.x+dx, mcf.y+dy)
      or ytileobj(hydramap(mcf.x+dx, mcf.y+dy, mode), mcf.x+dx, mcf.y+dy),
      tcs.x + (dx-1) * tilesize.x, tcs.y + (dy-.5) * tilesize.y, tilesize.x*2, tilesize.y)
    end end end
  
  tilesize.x = tilesize.x * 2
  return getAxCommon()
  end 

local lsetfppvar = setfppvar

function setfppvar()
  lsetfppvar()
  if inhex then
    loadheximages()
    fppvar.xz = math.sqrt(1/3)
    fppvar.hex = true
    fppvar.monpush = 0
    fppvar.objpush = 2
    end
  end 

function getisorot()
  if inhex then return 0 end
  return 1
  end

function hex_drawdisplayISO()

  isi = nil
  fillimage(D.output, 0, 0, xscrsize.x, xscrsize.y, vgaget(0))
  
  loadheximages()
  setmaparea()
  settilectr()
  tilesize.x = tilesize.x / 2
  tilesize.y = tilesize.y / 2
  recentermap()
  
  local mcf = V.floor(mapcenter)
  tcs = tilectr - (mapcenter - mcf) * tilesize

  dx0 = -math.ceil((tcs.x - maparea.top.x + 3*tilesize.x) / tilesize.x)
  dx1 = math.ceil((maparea.bot.x - tcs.x) / tilesize.x)
  dy0 = -math.ceil((tcs.y - maparea.top.y + 3*tilesize.y) / tilesize.y)
  dy1 = math.ceil((maparea.bot.y - tcs.y) / tilesize.y)
  
  for dy=dy0,dy1 do for dx=dx0,dx1 do if((dx+dy+mcf.x+mcf.y)%2 == inhexr) then
    local sg = 
      oldhydra and scrget(MAP, mcf.x+dx, mcf.y+dy)
      or hydramap(mcf.x+dx, mcf.y+dy, mode)
    drawtile(D.output, yiso(sg),
      tcs.x + (dx-1) * tilesize.x, tcs.y + (dy-2) * tilesize.y, tilesize.x*3, tilesize.y*3)
    drawtile(D.output, ytileobj(sg, mcf.x+dx, mcf.y+dy),
      tcs.x + (dx-.5) * tilesize.x, tcs.y + (dy-1.5) * tilesize.y, tilesize.x*2, tilesize.y*2)
    end end end
  
  tilesize.x = tilesize.x * 2
  tilesize.y = tilesize.y * 2
  return getAxCommon()
  end 

minimapborder = 0x303020

local ldrawMiniMap = drawMiniMap
function drawMiniMap()
  if trailer then return end
  if ininv then
  elseif inhex and minimode == modeBlock then
    scrcopy_f(MAP, 0,0, Minimap, 1,1, map.size.x, map.size.y, xminimap)
    for x=1,50 do
      for y=1,22 do
        if (x+y+1)%2 == inhexr then
          scrset(Minimap, x,y, scrget(Minimap, x-1,y))
          end
        end
      end
    drawscreen(D.output, Minimap, xscrsize.x-2*(map.size.x+2), xscrsize.y-3*(map.size.y+2), 2, 3)
  else
    ldrawMiniMap()
    end
  end

function addHexVariant(mode, fn)
  local orig = drawmap[mode]
  local function choose() 
    if inhex then return fn()
      else return orig()
      end
    end
  drawmap[mode] = choose
--drawmini[mode] = choose
  end

axInMap = axSemitransparent

addHexVariant(modeTiles, hex_drawdisplayTiles)
addHexVariant(modeMini, hex_drawdisplayMini)
addHexVariant(modeMed, hex_drawdisplayMini)
addHexVariant(modeISO, hex_drawdisplayISO)

local ldrawdisplay = drawdisplay
function drawdisplay()
  delayed_videomode()
    
  if hydrabox then
    local curtime = os.clock() * 100
    if not animatehydrastime then
      animatehydras(0)
    elseif animatehydrastime ~= curtime then
      animatehydras(curtime - animatehydrastime)
      end
    animatehydrastime =  curtime
    end
  oldhydra = VIEW or SERVER

  if oldhydra then
    local twincolor = gco(scrget(IMG, 52, 0))
    if twincolor ~= lasttwincolor then
      -- swapPlayerAndTwin()
      lasttwincolor = twincolor
      end
    end

  if inhex and mode == modeTiles then
    hex_drawdisplayTiles()
  elseif inhex and (mode == modeMini or mode == modeMed) and mapon then
    hex_drawdisplayMini()
  elseif inhex and mode == modeISO then
    hex_drawdisplayISO()
  else
    ldrawdisplay()
    end
  drawmessage()

  ldrawdisplay()
  mousetooltips()
  drawtrailer()
  end

function getminipos(size)
  if msgreserve * fontsize.y >= size.y-8 then 
    return V(D.rscreen.top.x, D.rscreen.bot.y - size.y)
  else
    return D.screen.top + (D.screen.size-size)
    end
  end

noteye_config_variable("hsmousepath", true, "pathfinding with mouse in Hydra Slayer")

noteye_config_variable("hsmousecfg", 2, "Hydra Slayer mouse tooltips", {options = gridoptions})

addtomenu(mainmenu, "x", writechoicef(
  function() 
    if hsmousecfg == 0 then return "Hydra Slayer mouse tooltips disabled"
    elseif hsmousecfg == 1 then return "Hydra Slayer mouse tooltips, no icons"
    elseif hsmousecfg == 2 then return "Hydra Slayer mouse tooltips and icons"
    elseif hsmousecfg == 3 then return "Hydra Slayer mouse disabled"
    end
    end),
  function()
    pickinteger("hsmousecfg", (hsmousecfg+1) % 4)
    return true
    end
  )

addtomenu(keysmenu, "p", writechoicef(
  function() return "pathfinding with mouse in Hydra Slayer: \ve"..boolonoff(hsmousepath) end),
  function()
    pickbool("hsmousepath", not hsmousepath)
    return true
    end
  )

function mousetooltips()
  -- do return end
  if hsmousecfg == 3 then return end
  mousemsg = ""
  if lastmm ~= nil then 
    checkmouse(lastmm)
    end
  local X1 = rscreen.bot.x - (minimode > 0 and 52 * minimapsize.x or 0)
  local Y1 = rscreen.bot.y

  if not VIEW and hsmousecfg ~= 0 then
    drawtile(D.output, tileshade(vgaget(15)), screen.top.x, Y1-fontsize.y, X1-screen.top.x, fontsize.y)
    end

  if mapon and lastmm ~= nil and hsmousecfg == 2 then

--  drawtile(D.output, tilerecolor(WT[0][4], 0xC0C0C0), X1-168, Y1-112, 168, 112)
    
    local iidx = 0
    local widx = -1
    
    local icowidth = fontsize.y >= 32 and 32 or 16
    local icoheight = icowidth
    
    local Y2 = Y1 - (fontsize.y - icoheight) / 2 - icoheight
    
    local icospace = 99
    
    if mousemsg then
      icospace = math.floor((X1 - fontsize.x*mousemsg:len()) / icowidth)
      end
    
    if lastmm.y >= Y1-fontsize.y then
      widx = math.floor((X1-lastmm.x)/icowidth)
      end
    
    function addicon(tile, stile)
      if iidx >= icospace then return end
      drawtile(D.output, icowidth >= 32 and tile or stile, X1-icowidth-icowidth*iidx, Y2, icowidth, icoheight)
      iidx = iidx+1
      return (widx+1) == iidx
      end
    
--  if addicon(AsciiMap) then
--    mousemsg = "Switch to ASCII map mode (Ctrl+M P)"
--    clickmouse = function() setmode(modeASCII) end
--    end
--  if addicon(Slayer) then
--    mousemsg = "(left click) tile mode (right click) mini-tile mode"
--    clickmouse = function(ev) if ev.button == 1 then setmode(modeTiles) else setmode(modeMini) end end
--    end
--  if addicon(FirstPP) then
--    clickmouse = function() setmode(modeISO) end
--    mousemsg = "Switch to ISO mode (Ctrl+M I)"
--    if not inhex then
--      clickmouse = function(ev) if ev.button == 1 then setmode(modeISO) else setmode(modeFPP) end end
--      mousemsg = "(left click) ISO mode (right click) FPP mode"
--      end
--    end
    if addicon(HelpIcon, SmHelpIcon) then
      mousemsg = "Help"
      mousesendstext("?", "Get help ('?')")
      end
    if addicon(SystemMenu, SmSystemMenu) then
      mousesendstext("S", "Main menu ('q')")
      end
    if addicon(Recycle, SmRecycle) then
      mousesendstext("g", "Pick up something or use stairs ('g')")
      end
    if addicon(Potion, SmInvIcon) then
      mousesendstext("i", "Inventory ('i')")
      end
    if addicon(WpnInfo, SmWpnInfo) then
      mousesendstext("v", "Information about the current weapon ('v')")
      end
    if addicon(WpnDrop, SmWpnDrop) then
      mousesendstext("d", "Drop the current weapon ('d')")
      end
    if addicon(AutoExplore, SmAutoExplore) then
      mousesendstext("o", "Auto-explore ('o')")
      end
    if addicon(Twin, SmTwinControl) then
      mousesendstext("c", "Switch twin control ('c')")
      end
    if addicon(Twin, SmTwinSelect) then
      mousesendstext("s", "Switch twin order ('s')")
      end
    if addicon(Target, SmTargetIcon1) then
      mousesendstext("t", "Target a ranged weapon ('t')")
      end
    if addicon(Bow, SmTargetIcon2) then
      mousesendstext("T", "Turn on/off auto-fire mode (Shift+T)")
      end
    if addicon(NoteyeMenu, SmNoteyeMenu) then
      clickmouse = noteyemenu
      mousemsg = "Go to NotEye menu (Ctrl+M)"
      end
    end

  if not trailer and hsmousecfg ~= 0 then
    Mouseline = renewscreen(Mouseline, 80, 1)
    scrfill(Mouseline, 0, 0, 80, 1, nil)
    scrwrite(Mouseline, 0, 0, mousemsg, Font, vgaget(0))
    drawscreen(D.output, Mouseline, screen.top.x, Y1-fontsize.y, fontsize.x, fontsize.y)
    end
  end

loadsounds()

local lreadgmessages = readgmessages

function readgmessages()
  -- the full inventory displays on top of the messages, which causes
  -- the system to repeat the sounds -- we do not want that
  if string.find(getline(0), "nventory") then return end
  return lreadgmessages()
  end  

if hydramain and not externalhydra then function rungamex(cmdline)
  P = internal(S, Font, cmdline)
  Ph = noteye_assign_handle(P)
  hydrauserdir(userdir)
  hydramain(Ph, mainloopcyc)
  end
  end

local lpixeltoprocess = pixeltoprocess

function hexround(v)
  if not inhex or not v then return v end
  local rx = v.x
  if mode == modeTiles then rx = rx-.5 end
  if not v then return v end
  v = V(math.floor(rx), math.floor(v.y))
  if v and inhex and (v.x+v.y+inhexr)%2 > 0.01 and not norounding then 
    if mode == modeASCII then
      if rx - v.x < .5 then v.x = v.x-1 else v.x = v.x+1 end
    else
      v.x = v.x-1
      end
    end
  return v
  end

function pixeltoprocess(ev)
--local function mf(z)
--  if norounding then return z
--  else return math.floor(z)
--  end
--  end
--print("ptp called")
  if inhex and mode == modeMed then
    mode = modeMini
    local result = lpixeltoprocess(ev)
    mode = modeMed
    return result
  elseif inhex and mode == modeTiles then
    return V(mapcenter.x + 1.5 + (ev.x - tilectr.x) / tilesize.x * 2,
      mapcenter.y + 0.5 + (ev.y - tilectr.y) / tilesize.y)
  elseif inhex and mode == modeISO then
    return V(mapcenter.x + (ev.x - tilectr.x) / tilesize.x*2,
      mapcenter.y + (ev.y - tilectr.y) / tilesize.y*2)
  else 
    return lpixeltoprocess(ev)
    end

  -- compare with 0.1 to take care about precision errors?
  return result
  end

if sethydrabox and not hydrabox then
  hydrabox = newimage(32*64, 32, 0x8080)
  hydraheads = loadimage(gfxdir.."hydraheads.png")
  local s = imggetsize(hydraheads)
  hydraheads2 = newimage(s.x, s.y)
  hydraheadskey = getpixel(hydraheads, 0, 0)
  sethydrabox(noteye_assign_handle(hydrabox), noteye_assign_handle(hydraheads), noteye_assign_handle(hydraheads2))
  animatedhydras = {}
  for u=0,63 do
    animatedhydras[u] = 
      tilespatial(addtile(hydrabox, u*32, 0, 32, 32, 0x8080), spMonst + spFlat + spIItem)
    end
  -- saveimage(hydraheads2, gfxdir.."hydraheads2.png")
  end

function sendquit()
  -- for libtcod as libnoteye user (not officially released)
  local id = 
    (string.find(getline(0), "Hydra Slayer") and string.find(getline(0), "Zeno"))
    and KEYS.s or KEYS.ESCAPE
  
  nsendkey(createkeydown(id))
  end

function dorotate(ev)
  return mapon and not string.find(getline(0), "nventory")
  end

function yesno(x) return x and "yes" or "no" end

intutorialmusic = true

-- lfadeoutmusic = fadeoutmusic

-- function fadeoutmusic(x)
  -- print("fadeout = "..x)
--   lfadeoutmusic(x)
--   end

-- do not play music after death
function checkmusic()
  if volmusic == 0 then return end
  if not curcoords then return end
  
  -- print("context = "..curcoords.context)

  -- see the last lines of classes.cpp for interface context meanings
  -- note that curcoords.level is 0-based, (-1 == tutorial, 0 = level 1, etc.)
  
  if
    curcoords.context == 16 or 
    curcoords.context == 17 or 
    curcoords.context == 27 or 
    curcoords.context == 28 or 
    curcoords.context == 29 or inmenu -- (NotEye menu)
  then inhydramenu = true end

  if curcoords.context == 0 or curcoords.context == 1 then
    inhydramenu = false
    end
  
  if not playeralive or not appactive then 
    if musicon() then stopmusic() end
    -- print("stop: player dead")
    return
    end
            

  -- print("inhydramenu = "..tostring(inhydramenu))
  
  if curcoords.level == -1 and not inhydramenu and playeralive and not musicon() and not curcoords.cangodown then  
    playmusicbyname(sounddir.."/music/music-tutorial.oga")
    intutorialmusic = true
    end

  if stopmusicat then
    -- print("stopmusicat = "..stopmusicat.." ticks = "..getticks())
    end

  if stopmusicat and stopmusicat < getticks() then
    fadeoutmusic(5000)
    stopmusicat = nil
    end
  
  -- if musicon() and inhydramenu then
  --  -- print("stop -- in menu")
  --  stopmusic()
  --  end
  
  -- print("level = "..(curcoords.level).." cangodown = "..tostring(curcoords.cangodown))
  
  if lastcoords and curcoords.cangodown and not lastcoords.cangodown then
    -- print("react to kill on level "..(curcoords.level))
    if curcoords.level == -1 then
      fadeoutmusic(1500)
    elseif curcoords.level == 9 then
      fadeoutmusic(1500)
    elseif curcoords.level == 11 then
      playmusicbyname(sounddir.."/music/music-0.oga")
      stopmusicat = getticks() + 26000
      intutorialmusic = false
    elseif curcoords.level == 49 then
      playmusicbyname(sounddir.."/music/music-0.oga")
      intutorialmusic = false
      -- 256 == dfChallenge
    elseif curcoords.level == 9 and bAND(curcoords.flags, 256) > 0 then
      playmusicbyname(sounddir.."/music/music-0.oga")
      stopmusicat = getticks() + 26000
      intutorialmusic = false
      end
    end
  
  local startmusic  
  if not lastcoords and curcoords and curcoords.level and curcoords.level >= 0 then
    startmusic = true
    end
  
  if lastcoords and curcoords.level ~= lastcoords.level then
    startmusic = true
    end

  if lastcoords and lastinhydramenu and not inhydramenu then
    startmusic = true
    end
  
  if lostfocus and appactive and not inhydramenu then
    startmusic = true
    lostfocus = false
    end
  
  if not inhydramenu and not startmusicat and appactive and playeralive and not startmusic then
    startmusicat = getticks() + 8000
    end
  
  if startmusicat and getticks() > startmusicat then
    startmusic = true
    end
  
  if startmusic and not musicon() and playeralive then
    -- print("react to change to level "..(curcoords.level))
    intutorialmusic = true
    if curcoords.level == -1 then
    elseif curcoords.level < 10 then    
      if tid110 == 1 then tid110 = 4
      elseif tid110 == 4 then tid110 = 5
      else tid110 = 1 end
      playmusicbyname(sounddir.."/music/music-1to10-"..tid110..".oga")
    elseif curcoords.level == 10 or curcoords.level == 11 or (curcoords.level >= 47 and curcoords.level <= 49) then
      playmusicbyname(sounddir.."/music/music-47to49.oga")
    elseif curcoords.level < 50 then
      playmusicbyname(sounddir.."/music/music-31to46-1.oga")
    else 
      playmusicbyname(sounddir.."/music/music-47to49.oga")
      end
    end
  
  lastcoords = curcoords
  lastinhydramenu = inhydramenu
  end

musicbyname = {}

function playmusicbyname(x)
  if not musicbyname[x] then 
    musicbyname[x] = loadmusic(x)
--  print("loaded "..x.." as: "..musicbyname[x])
    end
--print("playmusic: "..x)
  if musicbyname[x] then 
    musicvolume(volmusic)
    playmusic(musicbyname[x]) 
    end
  end

IsoParam = isoparam(32, 24, 32, 32)

--function setscreensize(xscrsize)
--  xscrsize.x = 1024
--  xscrsize.y = 768
--  end
mapextent = 1

setmainwindowtitle("Hydra Slayer "..(hydraver or ""))
cmdline = caller3("Hydra Slayer", "hydra")
defaultmodep(modeTiles, 3)

local lnoteyesleep = noteyesleep
  
function swapPlayerAndTwin()
  local tmp = moveanimations.player
  moveanimations.player = moveanimations.twin
  moveanimations.twin = tmp

  tmp = monster_attack_animations.twin
  monster_attack_animations.twin = monster_attack_animations.player
  monster_attack_animations.player = tmp
  end

function readevents()
  hs = hydrasounds()
  local k = 0
  while hs[k] do 
    local v = hs[k]
    k = k+1
    if v.swap then
      swapPlayerAndTwin()
      --local anim = monster_attack_animations["twin"]
      --monster_attack_animations["twin"] = monster_attack_animations["player"]
      --monster_attack_animations["player"] = anim
      --local anim = moveanimations["twin"]
      --moveanimations["twin"] = moveanimations["player"]
      --moveanimations["player"] = anim
    elseif v.hid then
      monster_attack_animations[v.hid] = {
        time = getticks(), vector = V(v.dx, v.dy)
        }
    elseif v.autoexplore then
      animateAutoexplore()
    elseif v.delay > 0 then
      scheduleTask(v.delay, function()
        playsoundfromfile(sounddir.."hydra-new/"..v.sound..".ogg", v.vol)
        end )
    else
      playsoundfromfile(sounddir.."hydra-new/"..v.sound..".ogg", v.vol)
      end
    end
  end

function noteyesleep(t)
  lnoteyesleep(t)
  end

function copygamedata()
  readevents()
  shareupdate()
  end
  
--local luisleep2 = uisleep2
--function uisleep2()
--  luisleep2()
--  end

local nhandlespecialkeys = handlespecialkeys
function handlespecialkeys(ev)
  if nhandlespecialkeys(ev) then return true end

  if iskey(ev, KEYS.F10) and ev.type == evKeyDown then     
    togglealtmode() -- dofile("games/hydra-genach.noe")
    return true

    end

  if iskey(ev, KEYS.F9) and ev.type == evKeyDown then     
    dofile("games/hydra-genach.noe")
    return true
    end

  if false and iskey(ev, KEYS.F8) and ev.type == evKeyDown then
    TileFullmap = V.renewscreen(TileFullmap, realmapsize)
    V.scrcopy(MAP, V(0,0), TileFullmap, 0, realmapsize, xtile)
    Img = newimage(tilesize.x * realmapsize.x, tilesize.y * realmapsize.y)
    for k,v in pairs(tilelayers) do
      V.drawscreenx(Img, TileFullmap, V(0,0), D.tilesize, getlayerX(v))
      end
    saveimage(Img, "bigmap.bmp")
    print("saving the map")
    end

  if false and iskey(ev, KEYS.F7) and ev.type == evKeyDown then
    TileFullmap = V.renewscreen(TileFullmap, V(60,45))
    Img = newimage(1920, 1440)
    for y=0,44 do for x=0,59 do 
      uu = (x+3*y) % 5
      floorcolor = 0x805050
      scrset(TileFullmap,x,y, tilerecolor(WT[10][uu], floorcolor))
      end end
    V.drawscreenx(Img, TileFullmap, V(0,0), V(32,32), TMAP_COPY)
    saveimage(Img, "emptymap.bmp")
    print("saving the empty map")
    end
  
  if false and iskey(ev, KEYS.F6) and ev.type == evKeyDown then
    invoke_trailer()
    return
    end

  end

altmode = {tsx=32, tsy=32, mode = modeASCII,  
  minimode = 0, msx=3, msy=5, minimoved = false,
  imagebackgrounds = false, hsmousecfg = 0
  }

function togglealtmode()
  local am = altmode
  setaltmode({
    tsx=tilesize.x, tsy=tilesize.y, 
    mode=mode, 
    minimode=minimode, msx=minimapsize.x, msy=minimapsize.y, minimoved = minimoved,
    imagebackgrounds = imagebackgrounds,
    mpx = cminipos and cminipos.x or 0, mpy = cminipos and cminipos.y or 0})
  tilesize.x = am.tsx
  tilesize.y = am.tsy
  minimapsize.x = am.msx
  minimapsize.y = am.msy
  minimoved = am.minimoved
  cminipos = {x = am.mpx, y = am.mpy}
  pickmode(am.mode)
  pickminimap(am.minimode)
  altmode.hsmousecfg = hsmousecfg pickinteger("hsmousecfg", am.hsmousecfg)
  pickbool("imagebackgrounds", am.imagebackgrounds)
  end

function setaltmode(am)
  cfgscripts.altmode = function(file)
    file:write("setaltmode({")
    for k,v in pairs(am) do 
      file:write(k.."="..(type(v) == "boolean" and booltf(v) or v)..",") 
      end
    file:write("cfg=1})\n")
    end
  altmode = am
  end

menuitems.missilespd.hidden = function() return true end

function stopmusic_lostfocus()
  stopmusic()
  lostfocus = true
  end

rungame(cmdline)
